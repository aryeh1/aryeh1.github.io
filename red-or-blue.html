<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>אדומים או כחולים</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * { box-sizing: border-box; }
        
        body { 
            background-color: #020202; 
            margin: 0; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
            font-family: 'Courier New', monospace; 
        }
        
        .app-container {
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            z-index: 10;
        }

        .header {
            text-align: center;
            opacity: 0.9;
            mix-blend-mode: exclusion;
            pointer-events: auto;
            cursor: pointer;
            padding: 10px;
        }

        .footer {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            opacity: 0.4;
            letter-spacing: 2px;
            text-shadow: 0 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useCallback } = React;
        const WORKER_URL = "https://game-backend.ary108.workers.dev/";

        // --- מנוע פיזיקלי ---
        const OrganicCanvas = ({ absorbedValue, onParticleAbsorbed, setCanvasRef }) => {
            const canvasRef = useRef(null);
            
            const stateRef = useRef({
                particles: [],
                sparks: [],
                ripples: [],
                blobRadius: 4,
                targetRadius: 4,
                wobble: 0,
                wobblePhase: 0,
                noiseOffset: 0
            });
            
            // Callback ref to avoid stale closure
            const onAbsorbedRef = useRef(onParticleAbsorbed);
            useEffect(() => {
                onAbsorbedRef.current = onParticleAbsorbed;
            }, [onParticleAbsorbed]);

            useEffect(() => {
                if (setCanvasRef) {
                    setCanvasRef({
                        spawnParticle: (x, y, type, amount) => {
                            const rect = canvasRef.current.getBoundingClientRect();
                            const relX = (x - rect.left) * (canvasRef.current.width / rect.width);
                            const relY = (y - rect.top) * (canvasRef.current.height / rect.height);
                            
                            const centerX = canvasRef.current.width / 2;
                            const centerY = canvasRef.current.height / 2;

                            const angle = Math.atan2(centerY - relY, centerX - relX);
                            
                            const speed = 0.1 + Math.random() * 0.1; 
                            
                            const shapes = ['square', 'triangle', 'diamond', 'circle'];
                            const shape = shapes[Math.floor(Math.random() * shapes.length)];

                            stateRef.current.particles.push({
                                x: relX, y: relY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                type,
                                amount, // כמה שווה החלקיק הזה
                                shape,
                                size: 3 + Math.random() * 3,
                                rotation: Math.random() * Math.PI,
                                rotSpeed: (Math.random() - 0.5) * 0.05
                            });
                        }
                    });
                }
            }, [setCanvasRef]);

            // גודל הליבה מבוסס על מה שנספג בפועל
            useEffect(() => {
                const absVal = Math.abs(absorbedValue);
                const minSize = 4;
                let calculatedRadius = minSize + Math.pow(absVal, 0.45) * 1.2;
                const maxScreen = Math.max(window.innerWidth, window.innerHeight) * 0.8;
                stateRef.current.targetRadius = Math.min(calculatedRadius, maxScreen);
            }, [absorbedValue]);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d', { alpha: false });
                let frameId;

                const render = () => {
                    const state = stateRef.current;
                    const w = canvas.width;
                    const h = canvas.height;
                    const cx = w / 2;
                    const cy = h / 2;

                    // פיזיקה
                    state.blobRadius += (state.targetRadius - state.blobRadius) * 0.05;
                    state.wobble *= 0.9;
                    state.wobblePhase += 0.1;
                    state.noiseOffset += 0.01;

                    // ציור
                    ctx.fillStyle = '#020202';
                    ctx.fillRect(0, 0, w, h);

                    // רקע עדין
                    const gradRed = ctx.createLinearGradient(0, 0, w * 0.25, 0);
                    gradRed.addColorStop(0, 'rgba(40, 0, 0, 0.15)');
                    gradRed.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradRed;
                    ctx.fillRect(0, 0, w/2, h);

                    const gradBlue = ctx.createLinearGradient(w, 0, w * 0.75, 0);
                    gradBlue.addColorStop(0, 'rgba(0, 0, 40, 0.15)');
                    gradBlue.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradBlue;
                    ctx.fillRect(w/2, 0, w/2, h);

                    // חלקיקים
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        const p = state.particles[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.rotation += p.rotSpeed;
                        
                        const dx = cx - p.x;
                        const dy = cy - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        // פגיעה במרכז
                        if (dist < state.blobRadius + state.wobble + 5) {
                            
                            // עדכון הספיגה - זה מה שמשפיע על גודל הליבה!
                            if (onAbsorbedRef.current) {
                                onAbsorbedRef.current(p.amount);
                            }
                            
                            // פיצוץ
                            for(let k=0; k<8; k++) {
                                state.sparks.push({
                                    x: p.x, y: p.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 1.0,
                                    color: p.type === 'blue' ? '#dbeafe' : '#fee2e2'
                                });
                            }
                            
                            state.wobble += 3;
                            state.ripples.push({ r: state.blobRadius, opacity: 0.5, type: p.type });
                            state.particles.splice(i, 1);
                            continue;
                        }

                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        ctx.fillStyle = p.type === 'blue' ? '#3b82f6' : '#ef4444';
                        ctx.beginPath();
                        const s = p.size;
                        if (p.shape === 'square') ctx.rect(-s, -s, s*2, s*2);
                        else if (p.shape === 'triangle') {
                            ctx.moveTo(0, -s); ctx.lineTo(s, s); ctx.lineTo(-s, s);
                        } else if (p.shape === 'diamond') {
                            ctx.moveTo(0, -s*1.5); ctx.lineTo(s, 0); ctx.lineTo(0, s*1.5); ctx.lineTo(-s, 0);
                        } else ctx.arc(0, 0, s, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }

                    // ניצוצות
                    for (let i = state.sparks.length - 1; i >= 0; i--) {
                        const s = state.sparks[i];
                        s.x += s.vx;
                        s.y += s.vy;
                        s.life -= 0.04;
                        if (s.life <= 0) {
                            state.sparks.splice(i, 1);
                            continue;
                        }
                        ctx.globalAlpha = s.life;
                        ctx.fillStyle = s.color;
                        ctx.beginPath();
                        ctx.rect(s.x, s.y, 2, 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    // גלי הדף
                    ctx.lineWidth = 1;
                    for (let i = state.ripples.length - 1; i >= 0; i--) {
                        const r = state.ripples[i];
                        r.r += 0.8;
                        r.opacity *= 0.95;
                        if (r.opacity < 0.05) {
                            state.ripples.splice(i, 1);
                            continue;
                        }
                        ctx.beginPath();
                        ctx.arc(cx, cy, r.r, 0, Math.PI * 2);
                        ctx.strokeStyle = r.type === 'blue' 
                            ? `rgba(96, 165, 250, ${r.opacity})` 
                            : `rgba(248, 113, 113, ${r.opacity})`;
                        ctx.stroke();
                    }

                    // הליבה - צבע מבוסס על absorbedValue
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.beginPath();
                    const segments = 60; 
                    for (let i = 0; i <= segments; i++) {
                        const theta = (i / segments) * Math.PI * 2;
                        const noise = Math.sin(theta * 5 + state.noiseOffset) * 2;
                        const impactWobble = Math.sin(theta * 4 + state.wobblePhase) * state.wobble;
                        const r = Math.max(1, state.blobRadius + noise + impactWobble);
                        const x = Math.cos(theta) * r;
                        const y = Math.sin(theta) * r;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(1, state.blobRadius));
                    if (absorbedValue >= 0) {
                        gradient.addColorStop(0, '#fff');
                        gradient.addColorStop(0.4, '#3b82f6');
                        gradient.addColorStop(1, '#172554');
                        ctx.shadowColor = '#60a5fa';
                    } else {
                        gradient.addColorStop(0, '#fff');
                        gradient.addColorStop(0.4, '#ef4444');
                        gradient.addColorStop(1, '#450a0a');
                        ctx.shadowColor = '#f87171';
                    }
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = Math.max(5, state.wobble * 3); 
                    ctx.fill();
                    ctx.restore();

                    frameId = requestAnimationFrame(render);
                };

                const resize = () => {
                    const parent = canvas.parentElement;
                    if (parent) {
                        canvas.width = parent.clientWidth;
                        canvas.height = parent.clientHeight;
                    }
                };
                window.addEventListener('resize', resize);
                resize();
                render();

                return () => {
                    cancelAnimationFrame(frameId);
                    window.removeEventListener('resize', resize);
                };
            }, [absorbedValue]);

            return <canvas ref={canvasRef} />;
        };

        // --- האפליקציה הראשית ---
        function App() {
            const [serverTotal, setServerTotal] = useState(0);
            const [displayBuffer, setDisplayBuffer] = useState(0);
            const [pendingBuffer, setPendingBuffer] = useState(0);
            const [absorbedLocal, setAbsorbedLocal] = useState(0); // מה שנספג בפועל (לגודל הליבה)
            const [username, setUsername] = useState('');
            const [devMode, setDevMode] = useState(false);
            
            const localBufferRef = useRef(0);
            const isSyncingRef = useRef(false);
            const cheatClicksRef = useRef([]); 
            
            const organicCanvasApi = useRef(null);
            
            // הערך המוצג (מה שהמשתמש הפעיל)
            const displayValue = serverTotal + pendingBuffer + displayBuffer;
            
            // הערך הנספג (לגודל הליבה) - serverTotal + מה שנספג מקומית
            const absorbedValue = serverTotal + absorbedLocal;

            // קולבק כשחלקיק נספג בליבה
            const handleParticleAbsorbed = useCallback((amount) => {
                setAbsorbedLocal(prev => prev + amount);
            }, []);

            useEffect(() => {
                if (window.Telegram?.WebApp) {
                    const user = window.Telegram.WebApp.initDataUnsafe?.user;
                    if (user?.first_name) setUsername(user.first_name);
                    window.Telegram.WebApp.ready();
                    window.Telegram.WebApp.expand();
                    window.Telegram.WebApp.setHeaderColor('#020202');
                }
                fetch(WORKER_URL).then(r=>r.json()).then(d => setServerTotal(d.entropy)).catch(()=>{});
            }, []);

            useEffect(() => {
                const syncLoop = setInterval(async () => {
                    if (devMode) return;
                    
                    if (isSyncingRef.current || localBufferRef.current === 0) {
                        if (localBufferRef.current === 0 && !isSyncingRef.current && Math.random() < 0.15) {
                            try {
                                const res = await fetch(WORKER_URL);
                                const data = await res.json();
                                setServerTotal(data.entropy);
                                // כשמקבלים עדכון מהשרת, מאפסים את הספיגה המקומית
                                // כי היא כבר נכללת ב-serverTotal
                            } catch(e){}
                        }
                        return;
                    }
                    
                    isSyncingRef.current = true;
                    const amountToSend = localBufferRef.current;
                    
                    localBufferRef.current = 0;
                    setDisplayBuffer(0);
                    setPendingBuffer(amountToSend);
                    
                    try {
                        const res = await fetch(WORKER_URL, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ delta: amountToSend })
                        });
                        const data = await res.json();
                        setServerTotal(data.entropy);
                        setPendingBuffer(0);
                        // אחרי סנכרון מוצלח, מאפסים את הספיגה המקומית
                        // כי מה שנספג כבר נכלל ב-serverTotal החדש
                        setAbsorbedLocal(0);
                    } catch (e) {
                        localBufferRef.current += amountToSend;
                        setDisplayBuffer(localBufferRef.current);
                        setPendingBuffer(0);
                    } finally {
                        isSyncingRef.current = false;
                    }
                }, 1500);
                return () => clearInterval(syncLoop);
            }, [devMode]);

            const handleTouch = useCallback((e) => {
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                if (!clientX) return;

                const width = window.innerWidth;
                const isRightSide = clientX > width / 2;
                const type = isRightSide ? 'blue' : 'red';
                const val = isRightSide ? 1 : -1;

                const amount = devMode ? val * 100 : val;

                // 1. שיגור חלקיק ויזואלי - עכשיו עם amount
                if (organicCanvasApi.current) {
                    organicCanvasApi.current.spawnParticle(clientX, clientY, type, amount);
                }

                // 2. עדכון ניקוד מיידי (לתצוגה בלבד - לא לגודל הליבה!)
                localBufferRef.current += amount;
                setDisplayBuffer(localBufferRef.current);

                if (navigator.vibrate) navigator.vibrate(3); 
            }, [devMode]);

            const handleCheatClick = useCallback(() => {
                const now = Date.now();
                const clicks = cheatClicksRef.current;
                clicks.push(now);
                
                if (clicks.length > 6) clicks.shift();

                if (clicks.length === 6) {
                    const [t1, t2, t3, t4, t5, t6] = clicks;
                    
                    const burst1 = (t3 - t1) < 800;
                    const burst2 = (t6 - t4) < 800;
                    const pause = (t4 - t3) > 1000 && (t4 - t3) < 3000;

                    if (burst1 && burst2 && pause) {
                        setDevMode(prev => !prev);
                        if (navigator.vibrate) navigator.vibrate([50, 50, 50, 100, 50]);
                        cheatClicksRef.current = [];
                    }
                }
            }, []);

            return (
                <div className="app-container text-gray-300">
                    <div className="game-area" onPointerDown={handleTouch}>
                        <OrganicCanvas 
                            absorbedValue={absorbedValue}
                            onParticleAbsorbed={handleParticleAbsorbed}
                            setCanvasRef={(api) => organicCanvasApi.current = api}
                        />
                        
                        <div className="ui-layer">
                            <div className="header" onClick={(e) => { e.stopPropagation(); handleCheatClick(); }}>
                                <div className="text-xs font-mono text-gray-500 tracking-widest uppercase mb-1">
                                    {username || 'Entity'}
                                </div>
                                <div className={`text-4xl font-bold font-mono tracking-tighter transition-colors duration-500
                                    ${displayValue > 0 ? 'text-blue-500' : 'text-red-500'}`}
                                    style={{ textShadow: `0 0 20px ${displayValue > 0 ? 'rgba(59,130,246,0.4)' : 'rgba(239,68,68,0.4)'}` }}>
                                    {Math.abs(displayValue).toLocaleString()}
                                </div>
                                {devMode && <div className="text-[9px] text-yellow-600 mt-1 tracking-widest">DEV OVERRIDE</div>}
                            </div>

                            <div className="footer">
                                <span className="text-blue-500">BLUE</span>
                                <span className="text-red-500">RED</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
