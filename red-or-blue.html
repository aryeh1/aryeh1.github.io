<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>אדומים או כחולים</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * { box-sizing: border-box; }
        
        body { 
            background-color: #020202; 
            margin: 0; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
            font-family: 'Courier New', monospace; 
        }
        
        .app-container {
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            z-index: 10;
        }

        .header {
            text-align: center;
            opacity: 0.9;
            mix-blend-mode: exclusion;
            pointer-events: auto;
            cursor: pointer;
            padding: 10px;
        }

        .footer {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            opacity: 0.4;
            letter-spacing: 2px;
            text-shadow: 0 1px 2px black;
        }

        .multiplier-popup {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 10px currentColor;
            animation: floatUp 0.8s ease-out forwards;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.3); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useCallback } = React;
        const WORKER_URL = "https://game-backend.ary108.workers.dev/";

        // חישוב מכפיל לפי מספר לחיצות
        const getMultiplier = (clicks) => {
            if (clicks < 100) return 1;
            if (clicks < 200) return 2;
            if (clicks < 400) return 4;
            if (clicks < 800) return 8;
            if (clicks < 1600) return 16;
            if (clicks < 3200) return 32;
            return 64;
        };

        // --- מנוע פיזיקלי ---
        const OrganicCanvas = ({ absorbedValue, onParticleAbsorbed, setCanvasRef }) => {
            const canvasRef = useRef(null);
            
            const stateRef = useRef({
                particles: [],
                sparks: [],
                ripples: [],
                serverBlobs: [], // גושים מעדכוני שרת
                blobRadius: 4,
                targetRadius: 4,
                wobble: 0,
                wobblePhase: 0,
                noiseOffset: 0
            });
            
            // Callback ref to avoid stale closure
            const onAbsorbedRef = useRef(onParticleAbsorbed);
            useEffect(() => {
                onAbsorbedRef.current = onParticleAbsorbed;
            }, [onParticleAbsorbed]);

            useEffect(() => {
                if (setCanvasRef) {
                    setCanvasRef({
                        spawnParticle: (x, y, type, amount) => {
                            const rect = canvasRef.current.getBoundingClientRect();
                            const relX = (x - rect.left) * (canvasRef.current.width / rect.width);
                            const relY = (y - rect.top) * (canvasRef.current.height / rect.height);
                            
                            const centerX = canvasRef.current.width / 2;
                            const centerY = canvasRef.current.height / 2;

                            const angle = Math.atan2(centerY - relY, centerX - relX);
                            const distToCenter = Math.sqrt(Math.pow(centerX - relX, 2) + Math.pow(centerY - relY, 2));
                            
                            const speed = 0.1 + Math.random() * 0.1; 
                            
                            const shapes = ['square', 'triangle', 'diamond', 'circle'];
                            const shape = shapes[Math.floor(Math.random() * shapes.length)];

                            const baseSize = 3 + Math.random() * 3;

                            stateRef.current.particles.push({
                                x: relX, y: relY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                type,
                                amount,
                                shape,
                                baseSize, // גודל מקורי
                                size: baseSize,
                                startDist: distToCenter, // מרחק התחלתי
                                rotation: Math.random() * Math.PI,
                                rotSpeed: (Math.random() - 0.5) * 0.05
                            });
                        },
                        // גוש מעדכון שרת
                        spawnServerBlob: (delta) => {
                            const canvas = canvasRef.current;
                            const centerX = canvas.width / 2;
                            // יוצא מאזור המספר (למעלה באמצע)
                            const startY = 80;
                            const centerY = canvas.height / 2;
                            
                            const type = delta >= 0 ? 'blue' : 'red';
                            const size = Math.min(50, 8 + Math.pow(Math.abs(delta), 0.4) * 2);
                            
                            const angle = Math.atan2(centerY - startY, 0);
                            const speed = 0.8 + Math.random() * 0.3;

                            stateRef.current.serverBlobs.push({
                                x: centerX,
                                y: startY,
                                vx: 0,
                                vy: speed,
                                type,
                                amount: delta,
                                size,
                                opacity: 0.8
                            });
                        }
                    });
                }
            }, [setCanvasRef]);

            // גודל הליבה מבוסס על מה שנספג בפועל
            useEffect(() => {
                const absVal = Math.abs(absorbedValue);
                const minSize = 4;
                let calculatedRadius = minSize + Math.pow(absVal, 0.45) * 1.2;
                const maxScreen = Math.max(window.innerWidth, window.innerHeight) * 0.8;
                stateRef.current.targetRadius = Math.min(calculatedRadius, maxScreen);
            }, [absorbedValue]);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d', { alpha: false });
                let frameId;

                const render = () => {
                    const state = stateRef.current;
                    const w = canvas.width;
                    const h = canvas.height;
                    const cx = w / 2;
                    const cy = h / 2;

                    // פיזיקה
                    state.blobRadius += (state.targetRadius - state.blobRadius) * 0.05;
                    state.wobble *= 0.9;
                    state.wobblePhase += 0.1;
                    state.noiseOffset += 0.01;

                    // ציור
                    ctx.fillStyle = '#020202';
                    ctx.fillRect(0, 0, w, h);

                    // רקע עדין
                    const gradRed = ctx.createLinearGradient(0, 0, w * 0.25, 0);
                    gradRed.addColorStop(0, 'rgba(40, 0, 0, 0.15)');
                    gradRed.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradRed;
                    ctx.fillRect(0, 0, w/2, h);

                    const gradBlue = ctx.createLinearGradient(w, 0, w * 0.75, 0);
                    gradBlue.addColorStop(0, 'rgba(0, 0, 40, 0.15)');
                    gradBlue.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradBlue;
                    ctx.fillRect(w/2, 0, w/2, h);

                    // חלקיקים
                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        const p = state.particles[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.rotation += p.rotSpeed;
                        
                        const dx = cx - p.x;
                        const dy = cy - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        // גדילה ליניארית - פי 3 מהגודל המקורי כשמגיע לליבה
                        const traveled = p.startDist - dist;
                        const progress = Math.max(0, Math.min(1, traveled / p.startDist));
                        p.size = p.baseSize * (1 + 1.1 * progress);
                        
                        // פגיעה במרכז
                        if (dist < state.blobRadius + state.wobble + 5) {
                            
                            // עדכון הספיגה - זה מה שמשפיע על גודל הליבה!
                            if (onAbsorbedRef.current) {
                                onAbsorbedRef.current(p.amount);
                            }
                            
                            // פיצוץ
                            for(let k=0; k<8; k++) {
                                state.sparks.push({
                                    x: p.x, y: p.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 1.0,
                                    color: p.type === 'blue' ? '#dbeafe' : '#fee2e2'
                                });
                            }
                            
                            state.wobble += 3;
                            state.ripples.push({ r: state.blobRadius, opacity: 0.5, type: p.type });
                            state.particles.splice(i, 1);
                            continue;
                        }

                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        ctx.fillStyle = p.type === 'blue' ? '#3b82f6' : '#ef4444';
                        ctx.beginPath();
                        const s = p.size;
                        if (p.shape === 'square') ctx.rect(-s, -s, s*2, s*2);
                        else if (p.shape === 'triangle') {
                            ctx.moveTo(0, -s); ctx.lineTo(s, s); ctx.lineTo(-s, s);
                        } else if (p.shape === 'diamond') {
                            ctx.moveTo(0, -s*1.5); ctx.lineTo(s, 0); ctx.lineTo(0, s*1.5); ctx.lineTo(-s, 0);
                        } else ctx.arc(0, 0, s, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }

                    // גושי שרת
                    for (let i = state.serverBlobs.length - 1; i >= 0; i--) {
                        const b = state.serverBlobs[i];
                        b.x += b.vx;
                        b.y += b.vy;
                        
                        const dx = cx - b.x;
                        const dy = cy - b.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        // פגיעה במרכז
                        if (dist < state.blobRadius + 10) {
                            if (onAbsorbedRef.current) {
                                onAbsorbedRef.current(b.amount);
                            }
                            
                            // פיצוץ גדול יותר
                            for(let k=0; k<20; k++) {
                                state.sparks.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 1.0,
                                    color: b.type === 'blue' ? '#93c5fd' : '#fca5a5'
                                });
                            }
                            
                            state.wobble += Math.min(15, b.size / 2);
                            state.ripples.push({ r: state.blobRadius, opacity: 0.7, type: b.type });
                            state.serverBlobs.splice(i, 1);
                            continue;
                        }
                        
                        // ציור גוש שרת - עיגול גדול עם זוהר
                        ctx.save();
                        ctx.globalAlpha = b.opacity;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                        const blobGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.size);
                        if (b.type === 'blue') {
                            blobGrad.addColorStop(0, '#93c5fd');
                            blobGrad.addColorStop(0.5, '#3b82f6');
                            blobGrad.addColorStop(1, '#1e40af');
                        } else {
                            blobGrad.addColorStop(0, '#fca5a5');
                            blobGrad.addColorStop(0.5, '#ef4444');
                            blobGrad.addColorStop(1, '#991b1b');
                        }
                        ctx.fillStyle = blobGrad;
                        ctx.shadowColor = b.type === 'blue' ? '#60a5fa' : '#f87171';
                        ctx.shadowBlur = 20;
                        ctx.fill();
                        ctx.restore();
                    }

                    // ניצוצות
                    for (let i = state.sparks.length - 1; i >= 0; i--) {
                        const s = state.sparks[i];
                        s.x += s.vx;
                        s.y += s.vy;
                        s.life -= 0.04;
                        if (s.life <= 0) {
                            state.sparks.splice(i, 1);
                            continue;
                        }
                        ctx.globalAlpha = s.life;
                        ctx.fillStyle = s.color;
                        ctx.beginPath();
                        ctx.rect(s.x, s.y, 2, 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    // גלי הדף
                    ctx.lineWidth = 1;
                    for (let i = state.ripples.length - 1; i >= 0; i--) {
                        const r = state.ripples[i];
                        r.r += 0.8;
                        r.opacity *= 0.95;
                        if (r.opacity < 0.05) {
                            state.ripples.splice(i, 1);
                            continue;
                        }
                        ctx.beginPath();
                        ctx.arc(cx, cy, r.r, 0, Math.PI * 2);
                        ctx.strokeStyle = r.type === 'blue' 
                            ? `rgba(96, 165, 250, ${r.opacity})` 
                            : `rgba(248, 113, 113, ${r.opacity})`;
                        ctx.stroke();
                    }

                    // הליבה - צבע מבוסס על absorbedValue
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.beginPath();
                    const segments = 60; 
                    for (let i = 0; i <= segments; i++) {
                        const theta = (i / segments) * Math.PI * 2;
                        const noise = Math.sin(theta * 5 + state.noiseOffset) * 2;
                        const impactWobble = Math.sin(theta * 4 + state.wobblePhase) * state.wobble;
                        const r = Math.max(1, state.blobRadius + noise + impactWobble);
                        const x = Math.cos(theta) * r;
                        const y = Math.sin(theta) * r;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(1, state.blobRadius));
                    if (absorbedValue >= 0) {
                        gradient.addColorStop(0, '#fff');
                        gradient.addColorStop(0.4, '#3b82f6');
                        gradient.addColorStop(1, '#172554');
                        ctx.shadowColor = '#60a5fa';
                    } else {
                        gradient.addColorStop(0, '#fff');
                        gradient.addColorStop(0.4, '#ef4444');
                        gradient.addColorStop(1, '#450a0a');
                        ctx.shadowColor = '#f87171';
                    }
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = Math.max(5, state.wobble * 3); 
                    ctx.fill();
                    ctx.restore();

                    frameId = requestAnimationFrame(render);
                };

                const resize = () => {
                    const parent = canvas.parentElement;
                    if (parent) {
                        canvas.width = parent.clientWidth;
                        canvas.height = parent.clientHeight;
                    }
                };
                window.addEventListener('resize', resize);
                resize();
                render();

                return () => {
                    cancelAnimationFrame(frameId);
                    window.removeEventListener('resize', resize);
                };
            }, [absorbedValue]);

            return <canvas ref={canvasRef} />;
        };

        // --- האפליקציה הראשית ---
        function App() {
            const [serverTotal, setServerTotal] = useState(0);
            const [displayBuffer, setDisplayBuffer] = useState(0);
            const [pendingBuffer, setPendingBuffer] = useState(0);
            const [absorbedLocal, setAbsorbedLocal] = useState(0);
            const [username, setUsername] = useState('');
            const [devMode, setDevMode] = useState(false);
            const [multiplierPopups, setMultiplierPopups] = useState([]);
            
            const localBufferRef = useRef(0);
            const isSyncingRef = useRef(false);
            const cheatClicksRef = useRef([]);
            const clickCountsRef = useRef({ blue: 0, red: 0 }); // מונה לחיצות לכל צד
            
            const organicCanvasApi = useRef(null);
            
            const displayValue = serverTotal + pendingBuffer + displayBuffer;
            const absorbedValue = serverTotal + absorbedLocal;

            const handleParticleAbsorbed = useCallback((amount) => {
                setAbsorbedLocal(prev => prev + amount);
            }, []);

            useEffect(() => {
                if (window.Telegram?.WebApp) {
                    const user = window.Telegram.WebApp.initDataUnsafe?.user;
                    if (user?.first_name) setUsername(user.first_name);
                    window.Telegram.WebApp.ready();
                    window.Telegram.WebApp.expand();
                    window.Telegram.WebApp.setHeaderColor('#020202');
                }
                fetch(WORKER_URL).then(r=>r.json()).then(d => setServerTotal(d.entropy)).catch(()=>{});
            }, []);

            // סנכרון כל 30 שניות, ללא polling פסיבי
            useEffect(() => {
                const syncLoop = setInterval(async () => {
                    if (devMode) return;
                    
                    // רק אם יש מה לשלוח
                    if (isSyncingRef.current || localBufferRef.current === 0) return;
                    
                    isSyncingRef.current = true;
                    const amountToSend = localBufferRef.current;
                    const prevServerTotal = serverTotal;
                    
                    localBufferRef.current = 0;
                    setDisplayBuffer(0);
                    setPendingBuffer(amountToSend);
                    
                    try {
                        const res = await fetch(WORKER_URL, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ delta: amountToSend })
                        });
                        const data = await res.json();
                        
                        // בדיקה אם יש עדכון מאחרים
                        const expectedTotal = prevServerTotal + amountToSend;
                        const deltaFromOthers = data.entropy - expectedTotal;
                        
                        if (Math.abs(deltaFromOthers) > 0 && organicCanvasApi.current) {
                            organicCanvasApi.current.spawnServerBlob(deltaFromOthers);
                        }
                        
                        setServerTotal(data.entropy);
                        setPendingBuffer(0);
                        setAbsorbedLocal(0);
                    } catch (e) {
                        localBufferRef.current += amountToSend;
                        setDisplayBuffer(localBufferRef.current);
                        setPendingBuffer(0);
                    } finally {
                        isSyncingRef.current = false;
                    }
                }, 30000);
                return () => clearInterval(syncLoop);
            }, [devMode, serverTotal]);

            // dev mode: סימולציה של עדכוני שרת כל 10 שניות
            useEffect(() => {
                if (!devMode) return;
                
                const simLoop = setInterval(() => {
                    if (organicCanvasApi.current) {
                        const fakeDelta = Math.floor((Math.random() - 0.5) * 1000);
                        organicCanvasApi.current.spawnServerBlob(fakeDelta);
                    }
                }, 10000);
                
                return () => clearInterval(simLoop);
            }, [devMode]);

            const handleTouch = useCallback((e) => {
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                if (!clientX) return;

                const width = window.innerWidth;
                const isRightSide = clientX > width / 2;
                const type = isRightSide ? 'blue' : 'red';
                const baseVal = isRightSide ? 1 : -1;

                // עדכון מונה לחיצות
                clickCountsRef.current[type]++;
                const clickCount = clickCountsRef.current[type];
                
                // חישוב מכפיל
                const prevMultiplier = getMultiplier(clickCount - 1);
                const currentMultiplier = getMultiplier(clickCount);
                
                // חיווי כשעוברים רמה
                if (currentMultiplier > prevMultiplier) {
                    const popupId = Date.now();
                    setMultiplierPopups(prev => [...prev, {
                        id: popupId,
                        x: clientX,
                        y: clientY,
                        multiplier: currentMultiplier,
                        type
                    }]);
                    setTimeout(() => {
                        setMultiplierPopups(prev => prev.filter(p => p.id !== popupId));
                    }, 800);
                    if (navigator.vibrate) navigator.vibrate([20, 30, 20]);
                }

                const amount = devMode ? baseVal * 100 : baseVal * currentMultiplier;

                if (organicCanvasApi.current) {
                    organicCanvasApi.current.spawnParticle(clientX, clientY, type, amount);
                }

                localBufferRef.current += amount;
                setDisplayBuffer(localBufferRef.current);

                if (navigator.vibrate) navigator.vibrate(3); 
            }, [devMode]);

            const handleCheatClick = useCallback(() => {
                const now = Date.now();
                const clicks = cheatClicksRef.current;
                clicks.push(now);
                
                if (clicks.length > 6) clicks.shift();

                if (clicks.length === 6) {
                    const [t1, t2, t3, t4, t5, t6] = clicks;
                    
                    const burst1 = (t3 - t1) < 800;
                    const burst2 = (t6 - t4) < 800;
                    const pause = (t4 - t3) > 1000 && (t4 - t3) < 3000;

                    if (burst1 && burst2 && pause) {
                        setDevMode(prev => !prev);
                        if (navigator.vibrate) navigator.vibrate([50, 50, 50, 100, 50]);
                        cheatClicksRef.current = [];
                    }
                }
            }, []);

            // חישוב מכפיל נוכחי לתצוגה
            const blueMultiplier = getMultiplier(clickCountsRef.current.blue);
            const redMultiplier = getMultiplier(clickCountsRef.current.red);

            return (
                <div className="app-container text-gray-300">
                    <div className="game-area" onPointerDown={handleTouch}>
                        <OrganicCanvas 
                            absorbedValue={absorbedValue}
                            onParticleAbsorbed={handleParticleAbsorbed}
                            setCanvasRef={(api) => organicCanvasApi.current = api}
                        />
                        
                        {/* Multiplier popups */}
                        {multiplierPopups.map(p => (
                            <div 
                                key={p.id}
                                className="multiplier-popup"
                                style={{
                                    left: p.x,
                                    top: p.y,
                                    color: p.type === 'blue' ? '#3b82f6' : '#ef4444'
                                }}
                            >
                                ×{p.multiplier}
                            </div>
                        ))}
                        
                        <div className="ui-layer">
                            <div className="header" onClick={(e) => { e.stopPropagation(); handleCheatClick(); }}>
                                <div className="text-xs font-mono text-gray-500 tracking-widest uppercase mb-1">
                                    {username || 'Entity'}
                                </div>
                                <div className={`text-4xl font-bold font-mono tracking-tighter transition-colors duration-500
                                    ${displayValue > 0 ? 'text-blue-500' : 'text-red-500'}`}
                                    style={{ textShadow: `0 0 20px ${displayValue > 0 ? 'rgba(59,130,246,0.4)' : 'rgba(239,68,68,0.4)'}` }}>
                                    {Math.abs(displayValue).toLocaleString()}
                                </div>
                                {devMode && <div className="text-[9px] text-yellow-600 mt-1 tracking-widest">DEV OVERRIDE</div>}
                            </div>

                            <div className="footer">
                                <span className="text-blue-500">
                                    BLUE {blueMultiplier > 1 && <span className="text-blue-400">×{blueMultiplier}</span>}
                                </span>
                                <span className="text-red-500">
                                    {redMultiplier > 1 && <span className="text-red-400">×{redMultiplier}</span>} RED
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
